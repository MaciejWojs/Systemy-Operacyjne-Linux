\documentclass[a4paper]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage{array}
\usepackage{biblatex}
\addbibresource{bibliography.bib}
\usepackage{csquotes}
\usepackage[shortlabels]{enumitem}
\usepackage{ifthen}
\usepackage{caption}
% \usepackage{verbatim}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{fvextra}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{microtype}
%BinaryBuilders 

\DefineVerbatimEnvironment{VerbatimBorder}{Verbatim}
{frame=single, framesep=10pt, rulecolor=\color{black}, framerule=0.4pt}

\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}%
{frame=single, framesep=10pt, rulecolor=\color{black}, framerule=0.4pt, breaklines=true}

\newcommand{\smaller}[1]{{\large #1}}
% \newcommand{\zdj}[2][width=\textwidth]{\includegraphics[#1]{#2}}
\newcommand*{\zdj}[2][\textwidth]{\includegraphics[width=#1]{#2}}
% \newcommand*{\lbl}[1][]{\label{#1}}

\newcommand*{\fg}[4][!htb]{
      \begin{figure*}[#1]
            \zdj{#2}
            \caption[#4]{#3}
      \end{figure*}
}

\newcommand*{\fgc}[5][!htb]{
      \begin{figure*}[#1]
            \phantomsection\label{fig:#5}
            \zdj{#2}
            \caption[#4]{#3}
      \end{figure*}
}

\newcommand*{\code}[1]{%
  \SaveVerb{#1}%
  \UseVerb{#1}%
}

\title{\textbf{Akademia Nauk Stosowanych w Nowym Sączu}\\\smaller{Wydział Nauk Inżynieryjnych}\vspace*{1em} \\ \textbf{Systemy operacyjne – projekt}\vspace*{0.5em}\\\smaller{studia stacjonarne\\semestr letni 2023/2024}}
\author{}
\date{}

\begin{document}
\maketitle

\textbf{Temat projektu:}
\begin{enumerate}
      \item Zaprojektować infrastrukturę informatyczną na potrzeby firmy BinaryBuilders. Realizacja
            serwerowa w oparciu o system operacyjny Linux, np.\@ Fedora Server 39, stacje klienckie
            np.\@ Linux MINT. %chktex 13

      \item Wdrożyć niezbędne usługi wynikające z założeń takie jak: SSH, DHCP, DNS, HTTP/S,
            motor bazodanowy (MySql)+PHP+phpMyAdmin, CMS WordPress, RAID, SAMBA,
            SQUID, Postfix(SMTP) + Dovecot(POP/IMAP), oraz wybraną usługę. Wdrożyć %chktex 36
            automatyzację przy użyciu skryptu np. Bash, oraz usługi cron.
      \item Cele projektu zweryfikować z założeniami zapisanymi w dokumencie „Szczegółowy
            zarys projektu”.
\end{enumerate}

% Increase row height by 50%
\renewcommand{\arraystretch}{1.25}
% Increase column spacing
\setlength{\tabcolsep}{12pt}

\begin{table}[h!]
      \centering
      \begin{tabular}{cccccc}
            Imie i nazwisko: &   &  &  & Data oddania: \\
            Maciej Wójs      &   &  &  & \today        \\
            Nr grupy:        &   &  &  & Ocena:        \\
            L3               &                         \\
      \end{tabular}
      % \caption{Sample Table}
      % \label{tab:sample_table}
\end{table}

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage

\section{Założenia projektowe – wymagania}
\begin{enumerate}[a)] % chktex 9  chktex 10
      \item Systemy operacyjne: Fedora Server 39 lub inny serwer z rodziny Linux, oraz system kliencki
            np. Linux MINT.
      \item zarządzanie serwerem poprzez SSH, oraz emulator putty.exe
      \item nazwa serwera ma być zgodna z nazewnictwem: svrXX-firma, gdzie XX oznaczają dwie
            ostatnie cyfry numeru albumu wykonawcy, a firma to skrót nazwy swojej
            firmy (niepowtarzalny) – wymyślonej,
      \item na podstawie nazwy firmy należy założyć lokalną domenę o nazwie np. firma.ns i
            skonfigurować usługę DNS Server,
      \item adres IP serwera, zakres adresacji IP, oraz brama domyślna od strony sieci wewnętrznej
            VirtualBOXa (sieć LAN firmy) w której ma działać serwer DHCP ma mieć następujące
            wartości:
            \vspace{-2mm}
            % \begin{table}[h]
            \begin{center}
                  \begin{tabular}{cc}
                        adres IP:       & 192.168.230.1/24, \\
                        zakres:         & 192.168.230.10–60 \\
                        brama domyślna: & 192.168.230.1     \\
                  \end{tabular}
            \end{center}
            % \end{table}
            \vspace{-2mm}
      \item należy utworzyć macierz dyskowa programową na poziomie RAID 5 z dyskiem zapasowym.
            Uzyskać wypadkową pojemności macierzy 10GB. Przestrzeń macierzy podzielić na dwie
            równe partycje,
      \item Pierwszą partycję zamontować do punktu \textbf{/dysksieciowy}, a drugą do punktu \textbf{/kopie}.
            Zapewnić ich automatyczne montowanie podczas startu systemu,
      \item  serwer ma udostępniać zasób sieciowy o adresie UNC \textbf{\textbackslash \textbackslash sfs.firma.ns\textbackslash dysk} odnoszący się do systemu plików \textbf{/dysksieciowy} (ppkt. g),
      \item należy wdrożyć usługę WEB Server z obsługą PHP, oraz serwer bazodanowy zarządzany przez
            phpMyAdmin, oraz CMS WordPress, skonfigurować UserDir dla WEB Serwer'a,
      \item dostęp do sieci Internet z sieci wewnętrznej ma się odbywać za pośrednictwem serwera
            PROXY(squid), a aktywność pracowników firmy ma być monitorowana,
      \item w firmie należy wdrożyć serwer pocztowy, oraz klienta mail,
      \item zapewnić aby popularne usługi były dostępne jako oddzielne nazwy hostów, jak np.:
            \begin{itemize}
                  \item \textbf{www.firma.ns} (serwer www),
                  \item \textbf{poczta.firma.ns} (serwer poczty),
                  \item \textbf{sfs.firma.ns} (serwer samby),
            \end{itemize}
      \item wdrożyć automatyczną archiwizację systemu plików /home zawierającego katalogi użytkowników. Archiwizacja ma rozpoczynać się automatycznie codziennie o 21:00. W wyniku archiwizacji ma powstać plik\\ \textbf{home\_20240510.tar.gz} zapisany w \textbf{/kopie} (ppkt\. g)
      \item Dodatkowo wdrożyć dowolną usługę, ale taką która nie była wdrażana podczas zajęć.

\end{enumerate}
\section{Opis użytych technologi}
\subsection{SSH (Secure Shell)}
SSH to protokół sieciowy, który umożliwia bezpieczne zdalne logowanie oraz wykonywanie poleceń na odległym serwerze. Zapewnia szyfrowanie komunikacji, co chroni przed podsłuchiwaniem oraz atakami typu man-in-the-middle.

\subsection{DHCP (Dynamic Host Configuration Protocol)}
DHCP to protokół używany do automatycznego przydzielania adresów IP i innych parametrów konfiguracyjnych urządzeniom w sieci. Ułatwia zarządzanie siecią poprzez automatyczne przypisywanie ustawień.

\subsection{DNS (Domain Name System)}
DNS to system, który przekształca łatwe do zapamiętania nazwy domen (np.\ www.example.com) na adresy IP, które są wykorzystywane przez urządzenia sieciowe do komunikacji. DNS działa jak książka telefoniczna internetu.

\subsection{HTTP/S (Hypertext Transfer Protocol/Secure)}
HTTP to protokół komunikacyjny używany do przesyłania stron internetowych. HTTPS to jego bezpieczna wersja, która wykorzystuje TLS/SSL do szyfrowania danych, zapewniając poufność i integralność komunikacji między przeglądarką a serwerem.

\subsection{MySQL}
Popularny system zarządzania relacyjnymi bazami danych. Umożliwia przechowywanie i zarządzanie dużą ilością danych w strukturach tabelarycznych.

\subsection{PHP}
Skryptowy język programowania, często używany do tworzenia dynamicznych stron internetowych. PHP może komunikować się z bazami danych, takimi jak MySQL.

\subsection{phpMyAdmin}
Narzędzie webowe do zarządzania bazami danych MySQL.
Umożliwia wykonywanie operacji na bazach danych za pomocą interfejsu graficznego.

\subsection{CMS WordPress}
WordPress to system zarządzania treścią (CMS), który pozwala na łatwe tworzenie i zarządzanie stronami internetowymi. Jest bardzo popularny ze względu na swoją elastyczność, prostotę obsługi oraz bogaty ekosystem wtyczek i motywów.

\subsection{RAID (Redundant Array of Independent Disks)}
RAID to technologia, która łączy kilka dysków twardych w jedną jednostkę logiczną w celu poprawy wydajności i/lub redundancji danych. Istnieje kilka poziomów RAID, z których każdy oferuje różne kombinacje wydajności i bezpieczeństwa danych.

\subsection{SAMBA}
SAMBA to pakiet oprogramowania, który umożliwia integrację systemów operacyjnych Linux/Unix z sieciami Windows. Pozwala na udostępnianie plików i drukarek w sieci oraz współpracę z domenami Windows (Active Directory).

\subsection{SQUID}
SQUID to serwer proxy i buforujący, który może przyspieszyć dostęp do zasobów internetowych poprzez przechowywanie często używanych danych w lokalnej pamięci podręcznej. Może również służyć jako filtr treści i narzędzie do monitorowania ruchu sieciowego.

\subsection{Postfix (SMTP) + Dovecot (POP/IMAP)}
\subsubsection{Postfix}
Serwer pocztowy obsługujący protokół SMTP, używany do wysyłania i odbierania wiadomości e-mail. Jest znany z wydajności i bezpieczeństwa.

\subsubsection{Dovecot}
Serwer IMAP i POP3 używany do odbierania i przechowywania wiadomości e-mail. Jest zoptymalizowany pod kątem wydajności i bezpieczeństwa, oferując wsparcie dla nowoczesnych standardów pocztowych.

\subsection{Automatyzacja za pomocą skryptów Bash i usług cron}
\subsubsection{Skrypty Bash}
Skrypty napisane w Bash (Bourne Again Shell) służą do automatyzacji zadań w systemach Unix/Linux. Mogą być używane do instalacji oprogramowania, konfiguracji systemu, zarządzania plikami i wielu innych zadań.

\subsubsection{cron}
Usługa systemowa w Unix/Linux, która pozwala na planowanie zadań do wykonania w określonym czasie lub regularnych odstępach czasu. Jest używana do automatyzacji zadań takich jak backup, aktualizacje systemu czy uruchamianie skryptów.

\section{Schemat logiczny projektowanej infrastruktury sieciowej}
\fg{contents/VirtualBox-network-setup/setup.png}{Schemat logiczny sieci}{Schemat logiczny sieci}
\newpage

\section{Procedury instalacyjne poszczególnych usług}
\subsection{Intalacja systeu klienta – Linux Mint}
\subsubsection{Proces instalacji}

\fg[h]{contents/OS_installation/Linux_mint/1.png}{Tworzenie nowej maszyny wirtualnej. Ustawienia nazwy, lokalizacji dysku oraz wybór pliku ISO systemu operacyjnego.}{Tworzenie nowej maszyny wirtualnej}

Pierwszym krokiem jest utworzenie nowej maszyny wirtualnej (VM). W tym etapie określa się nazwę maszyny, lokalizację dysku, gdzie będzie przechowywana, oraz wybiera odpowiedni plik ISO z systemem Linux Mint.

\fg{contents/OS_installation/Linux_mint/2.png}{Przydzielanie zasobów maszynie wirtualnej, takich jak pamięć RAM i procesor.}{Przydzielanie zasobów maszynie wirtualnej}

W kolejnym kroku przydzielane są zasoby dla maszyny wirtualnej, w tym ilość pamięci RAM oraz liczba rdzeni procesora.

% \newpage
\fg{contents/OS_installation/Linux_mint/3.png}{Określenie rozmiaru dysku wirtualnego.}{Określenie rozmiaru dysku wirtualnego.}

Następnie należy zdefiniować rozmiar wirtualnego dysku twardego, który będzie używany przez maszynę wirtualną.

\fg{contents/OS_installation/Linux_mint/4.png}{Podsumowanie konfiguracji maszyny wirtualnej przed rozpoczęciem instalacji systemu.}{Podsumowanie konfiguracji maszyny wirtualnej}

Po skonfigurowaniu wszystkich ustawień, wyświetlane jest podsumowanie zawierające wszystkie wybrane opcje dla nowo utworzonej maszyny wirtualnej.

\newpage

\fg{contents/OS_installation/Linux_mint/5.png}{Rozpoczęcie instalacji Linux Mint – wybór języka instalacji.}{Rozpoczęcie instalacji Linux Mint}

Rozpoczyna się proces instalacji Linux Mint. Pierwszym krokiem jest wybór języka, który będzie używany podczas instalacji i w systemie.

\fg{contents/OS_installation/Linux_mint/6.png}{Wybór trybu instalacji na dysku twardym.}{Wybór trybu instalacji na dysku twardym.}

Następnie użytkownik wybiera sposób instalacji systemu na dysku twardym, na przykład automatyczne partycjonowanie lub ręczne tworzenie partycji.

\newpage

\fg{contents/OS_installation/Linux_mint/7.png}{Tworzenie konta użytkownika i konfiguracja podstawowych ustawień.}{Tworzenie konta użytkownika}

Kolejnym krokiem jest utworzenie konta użytkownika, wprowadzenie nazwy użytkownika, hasła oraz nazwy komputera.

\fg{contents/OS_installation/Linux_mint/8.png}{Zakończenie instalacji systemu Linux Mint.}{Zakończenie instalacji systemu Linux Mint.}
Wyświetlony zostaje monit z prośbą o usunięcie nośnika instalacyjnego.
Po zakończeniu instalacji system wyświetla ekran informujący o pomyślnym zakończeniu procesu.

\newpage

\subsubsection{Wstępna konfiguracja systemu}

\fg{contents/OS_installation/Linux_mint/9.png}{Instalacja dodatków gościa dla poprawy wydajności i integracji z systemem hosta.}{Instalacja dodatków gościa}

Po zainstalowaniu systemu operacyjnego warto zainstalować dodatki gościa, które poprawiają integrację maszyny wirtualnej z systemem hosta, co zwiększa komfort pracy.

\fg{contents/OS_installation/Linux_mint/10.png}{Aktualizacja pakietów systemowych.}{Aktualizacja pakietów}

Ostatnim krokiem wstępnej konfiguracji jest aktualizacja pakietów systemowych, aby zapewnić, że system operacyjny ma najnowsze poprawki i funkcje.
\newpage
\subsection{Intalacja serwera – Fedora 40}
\subsubsection{Proces instalacji}
%\fg{contents/OS_installation/Fedora40/1.png}{Analogicznie jak w przypadku instalacji Linux Mint – ustwawiam nazwie}
% \fg{contents/OS_installation/Fedora40/2.png}{1}
% \fg{contents/OS_installation/Fedora40/3.png}{1}
\fg{contents/OS_installation/Fedora40/4.png}{Analogicznie jak w przypadku instalacji Linux Mint – wymagane jest ustawienie nazwy maszyny wirtualnej, przydzielenie jej zasobów, ustalenie rozmiaru dysku. Powyższe zdjęcie ukazuje ekran z podsumowaniem wybranych opcji}{Podsumowanie maszyny wirtualnej Fedora 40}
Aby maszyna wirtualna miała dostęp do internetu wymagane jest dodanie karty sieciowej NAT, co widać na poniższym zdjęciu.
\fg{contents/OS_installation/Fedora40/5.png}{Dodanie pierszej karty sieciowej – NAT}{Dodanie pierszej karty sieciowej}
\newpage
Druga karta sieciowa jest dodana w celu połączenia się hosta z maszyną wirtualną poprzez protokół SSH oraz udostępnienia usług takich jak http czy samba. Połączenie poprzez SSH umożliwia łatwiejszą konfigurację maszyny wirtualnej.
\fg{contents/OS_installation/Fedora40/6.png}{Dodanie pierszej drugiej karty sieciowej – sieć mostkowana (bridged)}{Dodanie drugiej karty sieciowej}

Trzecia karta sieciowa posłuży do stworzenia sieci wewnętrznej dla maszyn wirtualnych w sposób taki aby się one wzajemnie widziały (tzn. były dostępne), a nie były dostępne z poziomu hosta.
\fg{contents/OS_installation/Fedora40/7.png}{Dodanie pierszej trzeciej karty sieciowej – sieć wewnętrzna}{Dodanie trzeciej karty sieciowej}
\newpage
Po dodaniu kart sieciowych można uruchomić maszynę wirtualną. Po chwili ukazuje się menu grub z opcją instalacji Fedory 40. Tą opcję należy wybrać w celu dalszej instalacji.
\fg{contents/OS_installation/Fedora40/8.png}{Uruchomienie instalatora Fedory.}{Uruchomienie instalatora Fedory.}

W następnym kroku wybiera się język instalatora oraz układ klawiatury.
\fg{contents/OS_installation/Fedora40/9.png}{Rozpoczęcie instalacji Fedora 40 – wybór języka instalacji.}{Rozpoczęcie instalacji Fedora}
\newpage

W kolejnym kroku wybieram dysk na którym ma zostać zainstalowany system. W tym miejsco można podzielić dysk na partycje (podzielić na części które w systemie będą widoczne jako samodzielne dyski), sformatować go, zaszyfrować, wybrać system plików (np. ext3, ext4, zfs).
\fg{contents/OS_installation/Fedora40/10.png}{Wybór dysku na którym zostanie zainstalowany serwer}{Wybór dysku instalacji}


Następnie przechodzę do zakładki z ustawieniami dotyczącymi konta root. W tej zakładce ustwawiam hasło do konta oraz zezwalam na połączenia SSH tym kontem. Na serwerze produkcyjnym połączenie poprzez konto root nie jest zalecanym rozwiązaniem, gdyż stanowi zagrożenie bezpieczeństwa sieci firmowej.
\fg{contents/OS_installation/Fedora40/11.png}{Ustawienie konta root – włączenie konta, ustawienie hasła i zezwolenie na połączenie ssh jako root}{Ustawienie konta root}
\newpage

Po ustawieniu konta root'a zabieram się za stworzenie konta użytkownika. W tej części konfiguracji zaznaczam checkbox'a dotyczącego dodania konta admin do grupy wheel. Umożliwi mi to wykonywanie komendy sudo (Super User DO).
\fg{contents/OS_installation/Fedora40/12.png}{Stworzenie użytkownia – admin}{Stworzenie użytkownia}

Po wykonaniu powyższych kroków nie pozostaje nic innego jak rozpoczęcie instalacji.
\fg{contents/OS_installation/Fedora40/13.png}{Ekran postępującej instalacji}{Ekran postępującej instalacji}
\newpage

Po jakimś czasie mogę uruchomić ponownie serwer kończąc tym samym instalację systemu.
\fg{contents/OS_installation/Fedora40/14.png}{Ekran postępującej instalacji – koniec instalacji}{Ekran przed restartem do systemu.}

Po Uruchomieniu ponownym mogę zalogować się na konto root'a i zacząć konfigurację wstępną serwera.
\fg{contents/OS_installation/Fedora40/15.png}{Zainstalowany system – przed wstępną konfiguracją}{Zainstalowany system Fedora 40}
\newpage

\subsubsection{Wstępna konfiguracja}
% \fg{contents/OS_installation/Fedora40/16.png}{1}{2}
Po zainstalowaniu systemu, następnym krokiem powinno być zaktualizowanie pakietów aby zapewnić najnowszą funkcjonalność oraz poprawki bezpieczeństwa. Jednakże przed tym krokiem decyduję się na konfigurację menadżera pakietów dnf, aby przyśpieszyć pobieranie pakietów. Do pliku /etc/dnf/dnf.conf dodaje następujące wpisy:

\begin{Verbatim}[frame=single]
#Zmiany wprowadzone recznie
max_parallel_downloads=7
fastestmirror=1
deltarpm=0
\end{Verbatim}

Wytłumaczenie opcji: \\

\begin{itemize}
\item max\_parallel\_downloads=7
Opcja ta pozwala menadżerowi pakietów na pobieranie do 7 pakietów na raz.
\item fastestmirror=1
Opcja ta wymusza wyszukiwanie najszybszego serwera zwierciadlanego.
\item deltarpm=0
\end{itemize}

\fg{contents/OS_installation/Fedora40/17.png}{Dodanie wpisów do /etc/dnf/dnf.conf aby przyśpieszyć działanie menadżera pakietów dnf}{Konfiguracja dnf}
% Ostateczny wygląd pliku /etc/dnf/dnf.conf
% \begin{Verbatim}[frame=single]
% # see `man dnf.conf` for defaults and possible options

% [main]
% gpgcheck=True
% installonly_limit=3
% clean_requirements_on_remove=True
% best=False
% skip_if_unavailable=True

% #Zmiany wprowadzone recznie
% max_parallel_downloads=7
% fastestmirror=1
% deltarpm=0
% \end{Verbatim}
\newpage
Teraz po skonfigurowaniu menadżera pakietów można wykonać aktualizację pakietów.
\fg{contents/OS_installation/Fedora40/18.png}{Aktualizacja pakietów systemowych – test konfiguracji dnf}{Aktualizacja pakietów}
% \fg{contents/OS_installation/Fedora40/19.png}{1}{2}
% \fg{contents/OS_installation/Fedora40/20.png}{1}{2}


Po aktualizacji pakietów postanowiłem edytować irytującą mnie rzecz tj. uruchamianie się gruba przy jednym systemie opereracyjnym.
Na poniższym zdjęciu jest plik /etc/default/grub oryginalny (przed modyfikacją)
\fg{contents/OS_installation/Fedora40/21.png}{plik /etc/default/grub przed zmianą}{plik /etc/default/grub przed zmianą}
\newpage
W kolejnym kroku zmieniłem GRUB\_TIMEOUT=5 na GRUB\_TIMEOUT=0
Co można zauważyć poniższym zdjęciu.
\fg{contents/OS_installation/Fedora40/22.png}{plik /etc/default/grub po zmianie.}{plik /etc/default/grub po zmianie}
% \fg{contents/OS_installation/Fedora40/23.png}{1}{2}


Aby zatwierdzić zmiany należy użyć komendy: 
\begin{Verbatim}[frame=single]
grub2-mkconfig -o /boot/grub2/grub2.cfg
\end{Verbatim}
\fg{contents/OS_installation/Fedora40/24.png}{Zastosowanie zmian po edycji grub}{Zastosowanie zmian po edycji grub}
\newpage
W następnym kroku postanowiłem ułatwić wpisywanie hasła, gdy korzystam z sudo.
\fg{contents/OS_installation/Fedora40/25.png}{Zwiększenie wygody wpisywania haseł – edycja pliku komendą sudo visudo}{Zwiększenie wygody wpisywania haseł}


Efekt powyższego kroku: 
\fg{contents/OS_installation/Fedora40/26.png}{Zwiększenie wygody wpisywania haseł – efekt działania po zmianach}{Efekt działania zmiany ustawień}
\newpage

\subsection{Konfiguracja SSH}
Aby umożliwić połączenie z SSH na serwerze (VirtualBox) w pierszej kolejności potrzebe jest ustawienie poprawnego adresu IP z sieci lokalnej dla karty ustawionej na sieć mostkowaną (w moim przypadku jest to enp0s8)
\fg{contents/configuration/SSH/1.png}{konfiguracja karty sieciowej}{konfiguracja karty sieciowej}


W serwerze Fedora 40 SSH jest domyślnie włączone i skonfigurowane. Wystarczy tylko się połączyć
\fg{contents/configuration/SSH/2.png}{Konfiguracja aplikacji PuTTY}{Konfiguracja PuTTY}
\newpage

Próba zalogowania na konto root'a: 
\fg{contents/configuration/SSH/3.png}{Podlaczenie poprzez PuTTY na konto root'a}{Próba podłączenia poprzez PuTTY}

Wynik powyższego kroku:
\fg{contents/configuration/SSH/4.png}{Wynik połączenia poprzez PuTTY}{Wynik połączenia poprzez PuTTY}

\newpage

\subsection{Nazwa serwera – hostname}
Aby zmienić nazwę serwera (hostname) można użyć komendy: 
\vspace*{-5pt}
\begin{Verbatim}[frame=single]
hostnamectl set-hostname nazwa-komputera
\end{Verbatim}
\vspace*{-5pt}
\fg{contents/configuration/hostname/1.png}{Zmiana nazwy serwera}{Zmiana nazwy serwera}

\vspace*{-25pt}
\subsection{DNS – instalacja i konfiguracja}
Pierwszym krokiem w konfiguracji DNS jest dodanie odpowiedniego wpisu do /etc/hosts. W moim przypadku jest to:
\begin{Verbatim}[frame=single]
192.168.230.1 svr06-BinaryBuilders svr06-BinaryBuilders.ns
\end{Verbatim}
\fg{contents/configuration/DNS/1.png}{Edycja /etc/hosts}{Edycja /etc/hosts}

\newpage
Aby zainstalować oprogramowanie do stworzenia serwera DNS należy wydać polecenie:

\begin{itemize}
      \item Jeśli jesteś na koncie root:
\begin{Verbatim}[frame=single]
dnf install bind bind-utils -y
\end{Verbatim}

      \item jeżeli jesteś na innym koncie ale jesteś w grupie sudoers:  
\begin{Verbatim}[frame=single]
sudo dnf install bind bind-utils -y
\end{Verbatim}
\end{itemize}
Po zainstalowaniu wymaganych pakietów należy wykonać kopię zapasową plików konfiguracyjnych. Można to zrobić komendą: 

\begin{itemize}
      \item Jeśli jesteś na koncie root:
\begin{Verbatim}[frame=single]
cp /etc/named.conf /etc/named.conf.org
\end{Verbatim}

      \item jeżeli jesteś na innym koncie ale jesteś w grupie sudoers:  
\begin{Verbatim}[frame=single]
sudo cp /etc/named.conf /etc/named.conf.org
\end{Verbatim}
\end{itemize}

\fg{contents/configuration/DNS/2.png}{Instalacja DNS}{Instalacja DNS}

Następnie trzeba skonfigurować plik /etc/named.conf
Można zrobić to komendą:
\begin{Verbatim}
sudo nano /etc/named.conf
\end{Verbatim} 
\fg{contents/configuration/DNS/2.png}{Stworzenie kopii zapasowej pilku konfiguracyjnego DNS}{Kopia zapasowa pilku konfiguracyjnego DNS}
\newpage
\VerbatimInput[fontsize=\small]{contents/configuration/DNS/file_configs/1.txt}
Powyżej znajduje się zawatość pliku /etc/named.conf, którą należy wprowadzić.
\fg{contents/configuration/DNS/3.png}{zawatość named.conf}{zawatość named.conf}

W następnym kroku trzeba utworzyć plik strefy podstawowej. W moim przypadku jest to plik /var/BinaryBuilders.ns.lan\_in. Zawartość tego pliku:
\newpage
\VerbatimInput{contents/configuration/DNS/file_configs/2.txt}
\fg{contents/configuration/DNS/4.png}{zawatość pliku strefy podstawowej}{zawatość pliku strefy podstawowej}
W kolejnym kroku trzeba utworzyć plik strefy dla przeszukiwania wstecznego. W moim przypadku jest to plik /var/230.168.192.lan\_in. Zawartość tego pliku:
\VerbatimInput{contents/configuration/DNS/file_configs/3.txt}
\vspace{-10pt}
\fg{contents/configuration/DNS/5.png}{zawatość pliku strefy dla przeszukiwania wstecznego}{zawatość pliku strefy dla przeszukiwania wstecznego}

% \newpage
Następnym krokiem jest uruchomienie kilku komned:
\begin{Verbatim}[frame=single]
systemctl start named 
systemctl enable named
firewall-cmd --add-service=dns --permanent 
firewall-cmd --reload
nmcli con mod enp0s9 ipv4.dns 192.168.230.1
nmcli con down enp0s9 && nmcli con up enp0s9
rndc reload 
rndc status
\end{Verbatim}

Wytłumaczenie powyższych poleceń:
\begin{itemize}
      \item systemctl start named
      
      Komenda ta uruchomi usługę 
      \item systemctl enable named
      
Polecenie to spowoduje że usługa będzie uruchamiana automatycznie przy włączeniu serwera 
\item firewall-cmd --add-service=dns --permanent 

Dodaje regułę zapory sieciowej, aby na stałe zezwalać na ruch DNS.
\item firewall-cmd --reload

Przeładowuje ustawienia zapory sieciowej, aby zastosować wprowadzone zmiany.
\item nmcli con mod enp0s9 ipv4.dns 192.168.230.1

Modyfikuje połączenie enp0s9, aby używało serwera DNS o adresie 192.168.230.1.
\item nmcli con down enp0s9 \&\& nmcli con up enp0s9

Dezaktywuje i ponownie aktywuje połączenie sieciowe enp0s9.
\item rndc reload 

Przeładowuje konfigurację serwera serwera DNS.
\item rndc status

wyświetla status serwera serwera DNS.
\end{itemize}

\fg{contents/configuration/DNS/7.png}{Uruchomienie usługi DNS}{Uruchomienie usługi DNS}

Jak widać na zrzucie ekranu powyżej miałem problemy z błędną konfiguracją jednego z pliku, jednakże udało mi się naprawić problem i uruchomić usługę DNS.
Kolejnym i ostatnim krokiem jest test usługi DNS. Wykonać go można korzystając z drugiej maszyny wirtualnej. Przykładowy test DNS możesz zobaczyć
\hyperref[fig:dns-test]{\textbf{tutaj}.}

\vspace*{-5pt}
\subsection{DHCP – instalacja i konfiguracja}
Aby zainstalować oprogramowanie do stworzenia serwera DHCP należy wydać polecenie:

\vspace*{-5pt}
\begin{Verbatim}[frame=single]
sudo dnf install -y dhcp-server
\end{Verbatim}
\vspace*{-5pt}
\fg{contents/configuration/DHCP/1.png}{Instalacja DHCP}{Instalacja DHCP}
Po zainstalowaniu odpowiednich pakietów dobrze jest wykonać kopię zapasową oryginalnego pliku konfiguracji, co widać na zrucie powyżej. Można to zrobić następującą komendą:
\begin{Verbatim}[frame=single]
cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.org
\end{Verbatim}
\newpage
W następnym kroku należy wprowadzić zmiany w pliku konfiguracyjnym DHCP tj. /etc/dhcp/dhcpd.conf. W moim przypadku: 
\VerbatimInput{contents/configuration/DHCP/file_configs/1.txt}

Wprowadzoną treść widać na zrzucie poniżej. 
\fg{contents/configuration/DHCP/2.png}{Konfiguracja DHCP – edycja pliku /etc/dhcp/dhcpd.conf}{Konfiguracja DHCP}

\newpage
Następnym krokiem jest wprowadzenie kilku poleceń: 
\begin{Verbatim}[frame=single]
systemctl start dhcpd
systemctl enable dhcpd
firewall-cmd --add-service=dhcp --permanent
firewall-cmd --reload
\end{Verbatim}

Wytłumaczenie powyższych poleceń:
\begin{itemize}
\item systemctl start dhcpd

Komenda ta uruchomi usługę DHCP
\item systemctl enable dhcpd
 
Polecenie to spowoduje że usługa DHCP będzie uruchamiana automatycznie przy włączeniu serwera 
\item irewall-cmd --add-service=dhcp --permanent

Dodaje regułę zapory sieciowej, aby na stałe zezwalać na ruch DHCP.
\item firewall-cmd --reload

Przeładowuje ustawienia zapory sieciowej, aby zastosować wprowadzone zmiany.
\end{itemize}
Zrzut ekranu pooniżej przedstawia wykonanie tych komend.
\fg{contents/configuration/DHCP/3.png}{Instalacja DHCP}{Instalacja DHCP}

Po powyższym kroku nie pozostaje nic innego jak przetestować działanie DHCP. Wyniki testu dostępne są \hyperref[fig:dhcp-test]{\textbf{tutaj}.}

\newpage
\subsection{RAID 5 – konfiguracja}
Aby skonfigurować RAID 5 z 3 dysków głównych i jednym dyskiem zapasoym o wypadkowej pojemności 10GB, trzeba dodać 4 dyski o pojemności 5GB. 
\fg{contents/configuration/Raid5/1.png}{Dodanie dysków w VirtualBox}{Dodanie dysków w VirtualBox}

Po dodaniu dysków w VirtualBox należy uruchomić serwer. Po uruchomieniu serwera sprawdzam czy dyski są widoczne przez system operacyjny. Można to sprawdzić wykonując komendę:
\begin{Verbatim}[frame=single]
lsblk
\end{Verbatim}

Następnie tworzę macierz następującymi komendami: 
\begin{Verbatim}[frame=single,fontsize=\small, breaklines=true]
mdadm --create --verbose /dev/md0 --level=5 --raid-devices=3 /dev/sd[b-d] --spare-devices=1 /dev/sde
mdadm -D /dev/md0
\end{Verbatim}
Wytłumaczenie komend powyżej:
\begin{itemize}
      \item mdadm --create --verbose /dev/md0 --level=5 --raid-devices=3 /dev/sd[b-d] --spare-devices=1 /dev/sde
      
      Komenda ta tworzy macierz RAID 5 o nazwie /dev/md0 z trzech urządzeń (tutaj /dev/sdb, /dev/sdc, i /dev/sdd) i jednym urządzeniem zapasowym (/dev/sde). Parametr --verbose sprawia, że proces tworzenia macierzy będzie wyświetlał szczegółowe informacje na temat wykonywanych operacji.
      
      \item mdadm -D /dev/md0
      
      Polecenie to wyświetla szczegółowe informacje o istniejącej macierzy RAID /dev/md0. Pokazuje takie dane jak status macierzy, urządzenia składowe, poziom RAID i wiele innych.
      \end{itemize}
Na następnej stronie znajduje się zrzut ekranu prezentujący działanie tych poleneń.
\newpage
\fg{contents/configuration/Raid5/2.png}{Stworzenie macierzy raid 5}{Stworzenie macierzy raid 5}

% \fg{contents/configuration/Raid5/3.png}{Instalacja DHCP}{Instalacja DHCP}
Następnym krokiem jest wybranie schematu partycjonowania. Ja zostawiłem domyślny wybór – GPT
\fg{contents/configuration/Raid5/4.png}{Partycjonowanie macierzy narzędziem cfdisk}{Partycjonowanie macierzy narzędziem cfdisk}

\newpage
Kolejnym krokiem jest utworzenie dwóch partycji na macierzy, którą wcześniej stworzyłem.
\fg{contents/configuration/Raid5/5.png}{Stworzenie dwóch partycji – każda 5GB}{Stworzenie dwóch partycji}

Potwierdzenie działania poprzedniej komendy: 
\fg{contents/configuration/Raid5/6.png}{Wynik partycjonowania}{Wynik partycjonowania}

\newpage
Formatowanie przed chwilą stworzonych partycji (w systemie plików ext4), stworzenie katalogów /dysksieciowy, /kopie, zamontowanie partycji do tych katalogów oraz wyświetlenie id dysków i partycji w systtemie.
\fg{contents/configuration/Raid5/7.png}{Przygotowanie ścieżek do montowania}{Przygotowanie ścieżek do montowania}
% \fg{contents/configuration/Raid5/8.png}{Instalacja DHCP}{Instalacja DHCP}

Następnym krokiem jest zapewnienie automatycznego montowania utworzonych partycji. Aby to osiągnąć należy zmodyfikować /etc/fstab, ale najpierw wato wykonać kopię, gdyż jest to kluczowy składnik sysyemu. W razie awarii tego pliku nawet cały system może się nie uruchomić. Postanowiłem użyć id ponieważ jest niezmienne w przeciwieństwie do nazwy (np. /dev/md0p1 można zmienić). Tak wygląda moja tablica fstab:
\VerbatimInput{contents/configuration/Raid5/file_configs/fstab.txt}
\fg{contents/configuration/Raid5/9.png}{Edycja /etc/fstab}{Edycja /etc/fstab}
\vspace*{-5pt}
Test po ponownym uruchominiu jest dostępny \hyperref[fig:raid5-auto-mount-test]{\textbf{tutaj}.}

\vspace*{-5pt}
\subsection{Samba – instalacja i konfiguracja}
\vspace*{-5pt}
Aby zainstalować oprogramowanie do stworzenia serwera DHCP należy wydać polecenie:
\vspace*{-5pt}
\begin{Verbatim}[frame=single]
      sudo apt install samba-client samba -y
\end{Verbatim}
\vspace*{-5pt}

Po zainstalowaniu wymaganego oprogramowania wykonuję kopię zapasową pliku konfiguracyjnego samby. Można to zrobić komendą:
\vspace*{-5pt}
% \newpage
\begin{Verbatim}[frame=single]
cp /etc/samba/smb.conf /etc/samba/smb.conf.bk
\end{Verbatim}
% \fg{contents/configuration/Samba/1.png}{Samba – instalacja}{Samba – instalacja}
\fg{contents/configuration/Samba/2.png}{Samba – instalacja}{Samba – instalacja}
\newpage

Po wykonaniu kopii zapasowej można zabrać się za edycję /etc/samba/smb.conf. Tak wyglądda ten plik u mnie: 
\VerbatimInput{contents/configuration/Samba/file_configs/1.txt}
\fg{contents/configuration/Samba/3.png}{Edycja pliku /etc/samba/smb.conf}{Edycja pliku /etc/samba/smb.conf}

\newpage
Następnym krokiem jest wprowadzenie kilku poleceń: 
\begin{Verbatim}[frame=single]
testparam
systemctl start smb nmb
systemctl enable smb nmb
firewall-cmd --add-service=samba --permanent
firewall-cmd --reload
setsbool -P samba_export_all_rw on
\end{Verbatim}

Wytłumaczenie powyższych poleceń:
\begin{itemize}
      \item testparm
      
      Testuje i wyświetla aktualne ustawienia konfiguracji Samby. Używane jest do sprawdzenia pliku konfiguracyjnego Samba (smb.conf) pod kątem błędów i wyświetlenia aktywnych ustawień.
      
      \item systemctl start smb nmb
      
      Uruchamia usługi smb (serwer SMB) i nmb (serwer NetBIOS). Jest to wymagane, aby Samba mogła działać poprawnie i udostępniać zasoby w sieci.
      
      \item systemctl enable smb nmb
      
      Ustawia usługi smb i nmb do automatycznego uruchamiania przy starcie systemu. Dzięki temu nie trzeba ich ręcznie uruchamiać po każdym restarcie serwera.
      
      \item firewall-cmd --add-service=samba --permanent
      
      Dodaje regułę zapory sieciowej, aby na stałe zezwalać na ruch Samba. Umożliwia to komunikację Samby przez zaporę sieciową.
      
      \item firewall-cmd --reload
      
      Przeładowuje ustawienia zapory sieciowej, aby zastosować wprowadzone zmiany. Jest to konieczne po dodaniu nowych reguł do zapory.
      
      \item setsebool -P samba\_export\_all\_rw on
      
      Ustawia w SELinux politykę, która pozwala Sambie na eksportowanie wszystkich udziałów z prawami do odczytu i zapisu. Dzięki temu Samba może zarządzać plikami z pełnym dostępem zgodnie z ustawieniami SELinux.
\end{itemize}
Na następnej stronie znajduje się zrzut ekranu z wykonaniem tych komend.
\newpage 
      
      
      
\fg{contents/configuration/Samba/4.png}{Samba – ustawienia SELinux oraz firewall}{Samba – ustawienia SELinux oraz firewall}

Aby udział był dostępny pod addresem \textbackslash \textbackslash sfs.firma.ns\textbackslash dysk porzebna była zmiana konfiguracji DNS. Wymagane było dodanie linijki w pliku /var/named/BinaryBuilders.ns.lan\_in: 
\begin{Verbatim}[frame=single]
sfs IN A 192.168.230.1
\end{Verbatim}
\fg{contents/configuration/Samba/5 - edycja BinaryBuilders.ns.lan_in.png}{Edycja konfiguracji DNS}{Edycja konfiguracji DNS}

Po restarcie usługi named nie pozostaje nic innego jak sprawdzenie czy podłączenie do udziału działa. Test jest dostępny \hyperref[fig:samba-try-connection]{\textbf{tutaj}.}

% \fg{contents/configuration/Samba/6.png}{}{}


% \subsection{HTTP – instalacja i konfiguracja}
% \subsection{phpMyAdmin – instalacja i konfiguracja}
% \subsection{UserDir na serwerze HTTP – instalacja i konfiguracja}
% \subsection{wordpress – instalacja i konfiguracja}
% \subsection{proxy – instalacja i konfiguracja}
% \subsection{SMTP – instalacja i konfiguracja}
% \subsection{POP-IMAP – instalacja i konfiguracja}
% \subsection{Skrypt i crontab – konfiguracja}
\newpage


\section{Testy działania wdrożonych usług}
\subsection{DNS}
\vspace*{-10pt}
\fgc{contents/configuration/DNS/8.png}{Test DNS}{Test DNS}{dns-test}
Jak widać na powyższym zdjęciu system w sieci wewnętrznej dostaje odpowiedzi od serwera na zapytania, co sugeruje że uługa DNS została skonfigurowana poprawnie. 
\vspace*{-10pt}
\subsection{DHCP}
\vspace*{-10pt}
\fgc{contents/configuration/DHCP/4.png}{Instalacja DHCP}{Instalacja DHCP}{dhcp-test}
\vspace*{-5pt}
Jak widać na powyższym zdjęciu karta w systemie klienta ustawiona na sieć wewnętrzną dostała poprawny adres IP, adres bramy domyślnej i DNS. Na zdjęciu również widać że pula DHCP działa poprawnie. 
\newpage
\subsection{Raid 5}
\fgc{contents/configuration/Raid5/10.png}{Test automatycznego montowania partycji po ponownym uruchomieniu serwera}{Test automatycznego montowania}{raid5-auto-mount-test}
Jak widać na powyższym zrzucie ekranu po restarcie serwera partycje są montowane poprawnie. 

\subsection{Samba}
\fgc{contents/configuration/Samba/7.png}{Samba – próba podłączenia się do udziału na serwerze}{Samba – próba podłączenia się do udziału na serwerze}{samba-try-connection}
Aby podłączyć się z serwerem Samby należy otworzyć menadżer plików następnie otworzyć zakładkę Plik w lewym górnym rogu, następnie połącz z serwerem, kolejno w typie należy wybrać Udział Windows, ostatecznie należy wypełnić wymagane dane. Przykładowa próba podłączenia powyżej, a efekt tego działania poniżej.
\fgc{contents/configuration/Samba/8.png}{Samba – wynik poprzedniego kroku}{Samba – wynik poprzedniego kroku}{samba-connected}


\newpage
\section{Kod skryptu BASH, oraz tablica crontab}
FFFFFFFFFFFFFFFn
\section{Wnioski}
EEEEEEEEEEEEEE
\newpage
\nocite{k8s-docs}
\nocite{k8s-blog}
\nocite{k8s-github}
\printbibliography[heading=bibnumbered, label=Literatura, title=Literatura]
\end{document}